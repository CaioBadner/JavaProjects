import java.util.Random;

import javax.swing.JOptionPane;

public class HitOrMissCaioBadner {

	public static void main(String[] args) {
		
		JOptionPane.showMessageDialog(null, "\n" + "\n         GuessingGame 2.0               \n  "
										  + "\n ","GuessingGame 2.0", 3);
		
		
		int difficultyLevel = getValidDifficultyLevel();
		int maxAmountOfGuesses = getAmountOfGuessesByDifficultyLevel(difficultyLevel);
		
		int[] [] tableOfResults = new int[maxAmountOfGuesses+1][4];
		
		//this number cannot be larger than 9
		int numberLength = 4;
		
		int compNumber = generateValidComputerNumber(numberLength);
		
		int userGuess = 0, amountOfHits = 0, amountOfNearHits = 0;
		int currentRound = 1;
		
		boolean isUserWon = false;
		
		// 1st condition : I didn't run out of guesses
		// 2nd condition : I didn't win
		
		JOptionPane.showMessageDialog(null, "I am thinking of a " + numberLength + " digit number. "
				+ "\nTry to guess it! You have " + maxAmountOfGuesses + " guesses!"
			    + "\nOh, just a tip, there are NO repeated digits ;) ", "GuessingGame 2.0", 1);
		
		while(currentRound<=maxAmountOfGuesses && !isUserWon) {
			
			tableOfResults[0][3] = currentRound;
			
			tableOfResults[currentRound-1][0] = userGuess;
			tableOfResults[currentRound-1][1] = amountOfHits;
			tableOfResults[currentRound-1][2] = amountOfNearHits;
							
			System.out.println("If I were you, I would guess " + callForHelp(tableOfResults));
			
			userGuess = getValidUserGuess(numberLength);
		
			int[] results = calcResults(compNumber, userGuess, numberLength); 
			amountOfHits = results[0];
			amountOfNearHits = results[1];
			
			if (amountOfHits == numberLength) {
				System.out.println("Round " + currentRound + " | Your Guess: " + userGuess + " | Hits: " 
						+ amountOfHits + " | Near Hits: " + amountOfNearHits + " | Rounds left: " 
						+ (maxAmountOfGuesses - currentRound));
				isUserWon = true;
			}
			else {
				System.out.println("Round " + currentRound + " | Your Guess: " + userGuess + " | Hits: " 
						+ amountOfHits + " | Near Hits: " + amountOfNearHits + " | Rounds left: " 
						+ (maxAmountOfGuesses - currentRound));
				currentRound++;
			}
			
		
		}
		
		System.out.println("");
		
		if (isUserWon) {
			System.out.println("Guess nÂº" + currentRound + " (" + userGuess + ") was correct.");
			JOptionPane.showMessageDialog(null, "Nice! You got it right!! My number was " + compNumber,"GuessingGame 2.0", 2);
			if (currentRound == 1) {
				JOptionPane.showConfirmDialog(null, "Did you cheat?", "GuessingGame 2.0", 0);
			}
		}
		else {
			System.out.println("You have no more guesses. The answer was " + compNumber);
			JOptionPane.showMessageDialog(null, "It's ok, try an easier level next time... My number was " + compNumber,"GuessingGame 2.0", 0);
		}
	}

	
	private static int [] calcResults(int compNumber, int userGuess, int length) {
	
		int amountOfHits = 0, amountOfNearHits = 0;
		int userDigits, compDigits;
		int compCopy = compNumber;
		
		for (int i = 0; i < length; i++) {
			
			userDigits = userGuess % 10;
		
			for (int j = 0; j < length; j++) {
				compDigits = compCopy % 10;
				
				if (userDigits == compDigits) {
					if (i == j) {
						amountOfHits++;
					} else {
						amountOfNearHits++;
					}
					break;
				}
				compCopy = compCopy / 10;			
			}
			
			compCopy = compNumber;
			userGuess = userGuess / 10;
		}
	
		int[] results = {amountOfHits, amountOfNearHits};
		
		return results;
	}

	
	
	private static int getValidUserGuess(int length) {
		
		String USER_TEXT = "Please enter a " + length + " digit number with no repeating digits";
		
		String strUserGuess = JOptionPane.showInputDialog(null,USER_TEXT,"GuessingGame 2.0", 1);
		
		int userGuess = Integer.parseInt(strUserGuess);
		
		while(!isNumberValid(userGuess, length)) {
			strUserGuess = JOptionPane.showInputDialog(null,"Invalid number. " 
															+ USER_TEXT,"GuessingGame 2.0", 0);
			userGuess = Integer.parseInt(strUserGuess);
		}
		
		return userGuess;
	}

	private static boolean isNumberValid(int num, int length) {
		
		int [] digitCounter = new int[10];
		int digit;
	
		while (num > 0) {
			
			length --;
			
			if (length < 0) {
				return false;
			}
			
			digit = num % 10;
			
			digitCounter[digit] ++;
		
			if (digitCounter[digit] > 1) {
				return false;
			}
			num = num / 10;
			
			
		}
		
		if (length > 0) {
			return false;
		}
		
		return true;
	}

	private static int generateValidComputerNumber(int length) {
		Random rnd = new Random();
		int num, maxRandom = 1;
		for (int i = 0; i < length; i++) {
			maxRandom = maxRandom * 10;
		}
		do  {
			num = rnd.nextInt(maxRandom - (maxRandom/10)) + (maxRandom/10+1); 
		} while (!isNumberValid(num, length));
		
		return num;
	}

	private static int getAmountOfGuessesByDifficultyLevel(int difficultyLevel) {
		if (difficultyLevel == 1) {
			return 12;
		}
		
		if (difficultyLevel == 2) {
			return 9;
		}

		return 7;
	}

	private static int getValidDifficultyLevel() {
		
		String DIFF_TEXT = "Please choose difficulty level : \n"+
							"1.Easy - 12 guesses\n"+
							"2.Medium - 9 guesses\n"+
							"3.Hard - 7 guesses";
		
		String strDifficultyLevel = JOptionPane.showInputDialog(null,DIFF_TEXT,"GuessingGame 2.0", 1);
		
		int difficultyLevel = Integer.parseInt(strDifficultyLevel);
		
		while(difficultyLevel<1 || difficultyLevel>3) {
			strDifficultyLevel = JOptionPane.showInputDialog(null,"Invalid number, it should be 1-3\n"
					+ DIFF_TEXT,"GuessingGame 2.0", 0);
			difficultyLevel = Integer.parseInt(strDifficultyLevel);
		}
		
		return difficultyLevel;
	}




///////////////////////////
///
//
/*
 *              ARTIFICIAL INTELIGENCE LAB
 * 
 * 
 *              This is the zone where we try and develop an opponent 
 *              to play against the GuessingGame
 * 
 * 
 * 
 */
////
///////////////////////////////




private static int callForHelp(int[][] table) {
	
	//This array creates a map of digits against true/false odds
	// it has only been designed to solve a 4 digit number
	//
	// columns 0-3 symbolise the four digits' positions [3210] and column 4 is the general column
	// a TRUE in any field means that the digit has been declared eliminated from that position
	// 
	// for example:     if brain[3][1] == true  
	//                   then we know that the digit 3 cannot appear in position 1 xxXx  
	//
	// and the brain will learn that for example if 1st guess was 1234 and it came back with 0 hits
	//
	// if that guess had also 0 near hits, then brain[3][4] = true and now the digit 3 has been declared 
	// eliminated altogether from the answer
	
	boolean [][] brain = new boolean [10][5];
	
	int educatedGuess = 1234;	
	int counter = table[0][3];
	int round = counter - 1;
	 
	
	while (counter > 1) {
		
		//this is the situation where all four numbers are eliminated
		if (table[round][1] == 0 && table[round][2] == 0) {
			int num = table[round][0];
			for (int i = 0; i < 4; i++) {
				int digit = num % 10;
				brain[digit][4] = true;
				num = num / 10;
			}
		 
		
		//here we eliminate the number just in the position he came in the guess
		} else if (table[round][1] == 0 && table[round][2] < 4) {
			int num = table[round][0];
			for (int i = 0; i < 4; i++) {
				int digit = num % 10;
				brain[digit][i] = true;
				num = num / 10;
			}
		//this checks if this guess alone revealed all 4 digits	
		} else if (table[round][1] + table[round][2] == 4) {
			
			int num = table[round][0];
			byte d0 = (byte) (num % 10);
			num = num/10;
			byte d1 = (byte) (num % 10);
			num = num/10;
			byte d2 = (byte) (num % 10);
			num = num/10;
			byte d3 = (byte) (num % 10);
			brain[d0][4] = true;
			brain[d1][4] = true;
			brain[d2][4] = true;
			brain[d3][4] = true;
			
			for (int i = 0; i < 10; i++) {
				if (brain[i][4]) {
					brain[i][4] = false;
				} else {
					brain[i][4] = true;
				}
			
			}
			
			//and this checks if the two first guesses combined revealed all 4 digits	
		} /*else if (table[round][1] + table[round][2] + table[round-1][1] + table[round-1][2]  == 4) {
			
			int num = table[round][0];
			byte d0 = (byte) (num % 10);
			byte d1 = (byte) (num % 10);
			byte d2 = (byte) (num % 10);
			byte d3 = (byte) (num % 10);
			int num2 = table[round-1][0];
			byte d4 = (byte) (num2 % 10);
			byte d5 = (byte) (num2 % 10);
			byte d6 = (byte) (num2 % 10);
			byte d7 = (byte) (num2 % 10); 
			
			brain[d0][4] = true;
			brain[d1][4] = true;
			brain[d2][4] = true;
			brain[d3][4] = true;
			brain[d4][4] = true;
			brain[d5][4] = true;
			brain[d6][4] = true;
			brain[d7][4] = true; 
			
			for (int i = 0; i < 10; i++) {
				if (brain[i][4]) {
					brain[i][4] = false;
				} else {
					brain[i][4] = true;
				}
			
			}
			
		}
		*/
		
		
		
		
			//educatedGuess = 9123;
			//educatedGuess = 5678;
			//return educatedGuess;
			
		
		
		counter --;
		round --;
	}
	
		
			
			//this is the first complex check, we see if the first answer was decisive enough
		
		
		
		
	return educatedGuess;
	}






}

/*
private static boolean[][] readTable(int[][] table) {
	
	boolean [][] brain = new boolean [10][5];
	int round = table[0][3];
	
	
		while (round >= 0) {
			int num = table[round][0];
			while (num > 0) {
				int digit = num % 10;
	//			if ((table[round][1] + )
			}
		}
	return brain;
}
*/
